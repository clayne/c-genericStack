=for html <a href="https://travis-ci.org/jddurand/c-genericStack"><img src="https://travis-ci.org/jddurand/c-genericStack.svg?branch=master" alt="Travis CI build status" height="18"></a> <a href="https://badge.fury.io/gh/jddurand%2Fc-genericStack"><img src="https://badge.fury.io/gh/jddurand%2Fc-genericStack.svg" alt="GitHub version" height="18"></a> <a href="http://opensource.org/licenses/MIT" rel="nofollow noreferrer"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License MIT" height="18"></a>

=head1 NAME

genericStack - generic stack interface

=head1 DESCRIPTION

genericStack is like a va_list but in user-space, embedded within a single pointer. Most of the generic stack implementations either assume every element have the same size, either hide the typecasting checks from the compiler by going through a thin C-layer. This implementation support all native C data types, in addition to a "generic" type, and let the compiler warn if needed. It is done entirely with macros. Therefore we describe MACROS instead of METHODS below.

=head1 MACROS

=head2 GENERICSTACK_DECL(stackName)

Declare a stack with the name C<stackName>, which must be a valid C identifier.

=head2 GENERICSTACK_NEW(stackName)

Create an empty stack referenced with the name C<stackName>. The stack will automatically grow if needed.

=head2 GENERICSTACK_NEW_SIZED(stackName, wantedSize)

Create an empty stack referenced with the name C<stackName>, though pre-allocating room for C<wantedSize> elements>. The stack will also automatically grow if user if putting an element beyond C<wantedSize>.

=head2 GENERICSTACK_SET_XXX(stackName, var, index)

Set an entry in stack C<stackName>, at index C<index> (numbering start 0), using the result of the expression C<var>. XXX is meant to be a C datatype or I<ANY>, i.e. the exact list of macros is:

=over

=item GENERICSTACK_SET_CHAR

Set C<var> expression result, explicitely typecasted into a C<char>.

=item GENERICSTACK_SET_SHORT

Set C<var> expression result, explicitely typecasted into a C<short>.

=item GENERICSTACK_SET_INT

Set C<var> expression result, explicitely typecasted into an C<int>.

=item GENERICSTACK_SET_LONG

Set C<var> expression result, explicitely typecasted into a C<long>.

=item GENERICSTACK_SET_FLOAT

Set C<var> expression result, explicitely typecasted into a C<float>.

=item GENERICSTACK_SET_DOUBLE

Set C<var> expression result, explicitely typecasted into a C<double>.

=item GENERICSTACK_SET_PTR

Set C<var> expression result, explicitely typecasted into a C<void *>.

=back

C99 datatypes (see NOTES) may be available via:

=over

=item GENERICSTACK_SET_LONG_LONG

Set C<var> expression result, explicitely typecasted into a C<long long>.

=item GENERICSTACK_SET__BOOL

Set C<var> expression result, explicitely typecasted into a C<_Bool>.

=item GENERICSTACK_SET_FLOAT__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<float _Complex>.

=item GENERICSTACK_SET_DOUBLE__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<double _Complex>.

=item GENERICSTACK_SET_LONG_DOUBLE__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<long double _Complex>.

=back

=head2 GENERICSTACK_SET_ANY(stackName, var, clonep, freep, index)

  typedef void *(*genericStackClone_t)(void *p);
  typedef void  (*genericStackFree_t)(void *p);

Set an entry in stack C<stackName>, at index C<index> (numbering start 0), using the result of the expression C<var> that can be a pointer to anything, including opaque storage. C<clonep>, if provided, must be a function pointer that return a clone of C<var> expression. C<freep>, if provided, must be a function pointer that free the clone.

If C<clonep> is NULL, C<GENERICSTACK_SET_ANY> is functionnally equivalent to GENERICSTACK_SET_PTR()

If C<clonep> is not NULL, then it is the clone that is set. This clone will eventually be freed when GENERICSTACK_FREE() is called, using C<freep>, if the later is not NULL (if C<freep> is NULL, a memory leak is likely to happen, unless C<clonep> function is a function that is returning its argument -;).

=head2 GENERICSTACK_GET_XXX(stackName, index)

Get an entry in stack C<stackName>, at index C<index> (numbering start 0). The data type of the entry is left as-is, letting the compiler do type promotion, and eventually warn. XXX is meant to be a C datatype or I<ANY>, i.e. the exact list of macros is:

=over

=item GENERICSTACK_GET_CHAR

=item GENERICSTACK_GET_SHORT

=item GENERICSTACK_GET_INT

=item GENERICSTACK_GET_LONG

=item GENERICSTACK_GET_FLOAT

=item GENERICSTACK_GET_DOUBLE

=item GENERICSTACK_GET_PTR

=item GENERICSTACK_GET_ANY

Note that GENERICSTACK_GET_ANY() is functionnaly equivalent to GENERICSTACK_GET_PTR(), i.e. it returns a C<void *>.

=back

C99 datatypes (see NOTES) may be available via:

=over

=item GENERICSTACK_GET_LONG_LONG

=item GENERICSTACK_GET__BOOL

=item GENERICSTACK_GET_FLOAT__COMPLEX

=item GENERICSTACK_GET_DOUBLE__COMPLEX

=item GENERICSTACK_GET_LONG_DOUBLE__COMPLEX

=back

=head2 GENERICSTACK_PUSH_XXX(stackName, var)

This is an interface on top of <GENERICSTACK_SET_XXX>, that it automatically pushing data on the stack, the later will increase if needed.

=head2 GENERICSTACK_POP_XXX(stackName)

This is an interface on top of <GENERICSTACK_GET_XXX>, that it automatically popping data from the stack (i.e. retreive the last argument, and (artificially) reduce the generic stack size.

=head2 GENERICSTACK_FREE(stackName)

Release all the generic stack memory.

=head2 GENERICSTACK_ERROR(stackName)

Return a true value if there is an error. Should be called after every call to:

=over

=item GENERICSTACK_NEW(stackName)

=item GENERICSTACK_NEW_SIZED(stackName, wantedSize)

=item GENERICSTACK_SET_XXX(stackName, var, index)

=item GENERICSTACK_PUSH_XXX(stackName, var)

=back

=head2 GENERICSTACKITEMTYPE(stackName, index)

Returns the type of the item at position C<index> within stack C<stackName>.

=head2 GENERICSTACKITEMTYPE2TYPE_XXX

Generates a basic C type from the item type C<XXX>, for example:

=over

=item GENERICSTACKITEMTYPE2TYPE_CHAR

generates C<char>

=item GENERICSTACKITEMTYPE2TYPE_SHORT

generates C<short>

=back

and so on.

=head1 NOTES

=over

=item ANY datatype

As stated before, the generic stack always owns a data type created with GENERICSTACK_SET_ANY() or GENERICSTACK_PUSH_ANY(). This simply mean that, I<if> the user provide both a C<clonep> and a C<freep> method, he should I<not> call himself the C<freep> method after retreiving a pointer to the clone.

=item C99 datatypes

C99 data types are all available if the C<GENERICSTACK_C99> macro is defined. Otherwise, partial support of C99 from the compiler support is handled like this:

=over

=item GENERICSTACK_HAVE_LONG_LONG

If this #define is a true value, then C<long long> is supported.

=item GENERICSTACK_HAVE__BOOL

If this #define is a true value, then C<_Bool> is supported.

=item GENERICSTACK_HAVE__COMPLEX

If this #define is a true value, then C<float _Complex>, C<double _Complex> and C<long double _Complex> are supported.

=back

=back

=head1 EXAMPLE

  #include <stdio.h>
  #include <genericStack.h>

  void myFunction1(int arg1, GENERICSTACK_DECL(myStack), int argn);
  void myFunction2(int arg1, GENERICSTACK_DECL(myStack), int argn);

  typedef struct myStruct1 { int i; } myStruct1_t;
  typedef struct myStruct2 { int i; char *s; } myStruct2_t;

  void *myStruct2Clone(void *src) {
    void *p = malloc(sizeof(myStruct2_t));
    memcpy(p, src, sizeof(myStruct2_t));
    ((myStruct2_t *) p)->s = strdup(((myStruct2_t *) src)->s);
    return p;
  }

  void myStruct2Free(void *src) {
    free(((myStruct2_t *) src)->s);
    free(src);
  }

  int main() {
    myStruct1_t myStruct1 = { 50 };
    myStruct2_t myStruct2 = { 60, "70" };
  
    GENERICSTACK_DECL(myStack);

    GENERICSTACK_NEW        (myStack);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_INT   (myStack, 10);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_DOUBLE(myStack, 20);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_FLOAT (myStack, 30);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_SHORT (myStack, 40);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_ANY   (myStack, &myStruct1, NULL, NULL);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    GENERICSTACK_PUSH_ANY   (myStack, &myStruct2, myStruct2Clone, myStruct2Free);
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    myFunction1             (-1, myStack, 999);

    GENERICSTACK_SET_FLOAT  (myStack, 50, 10);  /* Indice 10 */
    if (GENERICSTACK_ERROR(myStack)) { return 1; }

    myFunction2             (-1, myStack, 999);

    GENERICSTACK_FREE       (myStack);

    return 0;
  }

  void myFunction1(int arg1, GENERICSTACK_DECL(myStack), int argn) {
    myStruct1_t *myStruct1p;
    myStruct2_t *myStruct2p;

    printf("[ 1] double   : %f\n", (float)   GENERICSTACK_GET_DOUBLE(myStack, 1));
    printf("[ 0] int      : %d\n",           GENERICSTACK_GET_INT   (myStack, 0));
    printf("[ 3] short    : %d\n",           GENERICSTACK_GET_SHORT (myStack, 3));
    printf("[ 5] myStruct2: {%d, \"%s\"}\n", ((myStruct2_t *) GENERICSTACK_GET_ANY (myStack, 5))->i,
                                             ((myStruct2_t *) GENERICSTACK_GET_ANY (myStack, 5))->s);
    printf("[ 4] myStruct1: {%d}\n",         ((myStruct1_t *) GENERICSTACK_GET_ANY (myStack, 4))->i);
    printf("[ 2] float    : %f\n",           GENERICSTACK_GET_FLOAT (myStack, 2));
  
    myStruct2p = (myStruct2_t *)        GENERICSTACK_POP_ANY(myStack);
    myStruct1p = (myStruct1_t *)        GENERICSTACK_POP_ANY(myStack);
    printf("[ 5] myStruct2: {%d, \"%s\"}\n", myStruct2p->i, myStruct2p->s);
    printf("[ 4] myStruct1: {%d}\n", myStruct1p->i);
    printf("[ 3] short : %d\n", (int)   GENERICSTACK_POP_SHORT(myStack));
    printf("[ 2] float : %f\n",         GENERICSTACK_POP_FLOAT(myStack));
    printf("[ 1] double: %f\n", (float) GENERICSTACK_POP_DOUBLE(myStack));
    printf("[ 0] int   : %d\n",         GENERICSTACK_POP_INT(myStack));
  }

  void myFunction2(int arg1, GENERICSTACK_DECL(myStack), int argn) {
    printf("[10] float : %f\n", GENERICSTACK_GET_FLOAT (myStack, 10));
  }
