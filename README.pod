=for html <a href="https://travis-ci.org/jddurand/c-genericStack"><img src="https://travis-ci.org/jddurand/c-genericStack.svg?branch=master" alt="Travis CI build status" height="18"></a> <a href="https://badge.fury.io/gh/jddurand%2Fc-genericStack"><img src="https://badge.fury.io/gh/jddurand%2Fc-genericStack.svg" alt="GitHub version" height="18"></a> <a href="http://opensource.org/licenses/MIT" rel="nofollow noreferrer"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License MIT" height="18"></a>

=head1 NAME

genericStack - generic stack interface

=head1 DESCRIPTION

genericStack is like a va_list but in user-space, embedded within a single pointer. Most of the generic stack implementations either assume every element have the same size, either hide the typecasting checks from the compiler by going through a thin C-layer. This implementation support all native C data types, in addition to a "generic" type, and let the compiler warn if needed. It is done entirely with macros. Therefore we describe MACROS instead of METHODS below.

=head1 MACROS

=head2 GENERICSTACK_DECL(stackName)

Declare a stack with the name C<stackName>, which must be a valid C identifier.

=head2 GENERICSTACK_NEW(stackName)

Create an empty stack referenced with the name C<stackName>. The stack will automatically grow if needed.

=head2 GENERICSTACK_NEW_SIZED(stackName, wantedSize)

Create an empty stack referenced with the name C<stackName>, though pre-allocating room for C<wantedSize> elements>. The stack will also automatically grow if user if putting an element beyond C<wantedSize>.

=head2 GENERICSTACK_SET_XXX(stackName, var, index)

Set an entry in stack C<stackName>, at index C<index> (numbering start 0), using the result of the expression C<var>. XXX is meant to be a C datatype, i.e. the exact list of macros is:

=over

=item GENERICSTACK_SET_CHAR

Set C<var> expression result, explicitely typecasted into a C<char>.

=item GENERICSTACK_SET_SHORT

Set C<var> expression result, explicitely typecasted into a C<short>.

=item GENERICSTACK_SET_INT

Set C<var> expression result, explicitely typecasted into an C<int>.

=item GENERICSTACK_SET_LONG

Set C<var> expression result, explicitely typecasted into a C<long>.

=item GENERICSTACK_SET_FLOAT

Set C<var> expression result, explicitely typecasted into a C<float>.

=item GENERICSTACK_SET_DOUBLE

Set C<var> expression result, explicitely typecasted into a C<double>.

=item GENERICSTACK_SET_PTR

Set C<var> expression result, explicitely typecasted into a C<void *>.

=back

C99 datatypes (see NOTES) may be available via:

=over

=item GENERICSTACK_SET_LONG_LONG

Set C<var> expression result, explicitely typecasted into a C<long long>.

=item GENERICSTACK_SET__BOOL

Set C<var> expression result, explicitely typecasted into a C<_Bool>.

=item GENERICSTACK_SET_FLOAT__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<float _Complex>.

=item GENERICSTACK_SET_DOUBLE__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<double _Complex>.

=item GENERICSTACK_SET_LONG_DOUBLE__COMPLEX

Set C<var> expression result, explicitely typecasted into a C<long double _Complex>.

=back

=head2 GENERICSTACK_SET_NA(stackName, index)

Specific macro that removes any association at position C<index>.

=head2 GENERICSTACK_GET_XXX(stackName, index)

Get an entry in stack C<stackName>, at index C<index> (numbering start 0). The data type of the entry is left as-is, letting the compiler do type promotion, and eventually warn. XXX is meant to be a C datatype, i.e. the exact list of macros is:

=over

=item GENERICSTACK_GET_CHAR

=item GENERICSTACK_GET_SHORT

=item GENERICSTACK_GET_INT

=item GENERICSTACK_GET_LONG

=item GENERICSTACK_GET_FLOAT

=item GENERICSTACK_GET_DOUBLE

=item GENERICSTACK_GET_PTR

=back

C99 datatypes (see NOTES) may be available via:

=over

=item GENERICSTACK_GET_LONG_LONG

=item GENERICSTACK_GET__BOOL

=item GENERICSTACK_GET_FLOAT__COMPLEX

=item GENERICSTACK_GET_DOUBLE__COMPLEX

=item GENERICSTACK_GET_LONG_DOUBLE__COMPLEX

=back

=head2 GENERICSTACK_PUSH_XXX(stackName, var)

This is an interface on top of <GENERICSTACK_SET_XXX>, that it automatically pushing data on the stack, the later will increase if needed.

=head2 GENERICSTACK_POP_XXX(stackName)

This is an interface on top of <GENERICSTACK_GET_XXX>, that it automatically popping data from the stack (i.e. retreive the last argument, and (artificially) reduce the generic stack size.

=head2 GENERICSTACK_FREE(stackName)

Release all the generic stack memory.

=head2 GENERICSTACK_ERROR(stackName)

Return a true value if there is an error. Should be called after every call to:

=over

=item GENERICSTACK_NEW(stackName)

=item GENERICSTACK_NEW_SIZED(stackName, wantedSize)

=item GENERICSTACK_SET_XXX(stackName, var, index)

=item GENERICSTACK_PUSH_XXX(stackName, var)

=back

=head2 GENERICSTACK_SWITCH(stackName, i1, i2)

Switches items at positions C<i1> and C<i2>.

=head2 GENERICSTACKITEMTYPE(stackName, index)

Returns the type of the item at position C<index> within stack C<stackName>.

=head2 GENERICSTACKITEMTYPE2TYPE_XXX

Generates a basic C type from the item type C<XXX>, for example:

=over

=item GENERICSTACKITEMTYPE2TYPE_CHAR

generates C<char>

=item GENERICSTACKITEMTYPE2TYPE_SHORT

generates C<short>

=back

and so on.

=head1 NOTES

=over

=item C99 datatypes

C99 data types are all available if the C<GENERICSTACK_C99> macro is defined. Otherwise, partial support of C99 from the compiler support is handled like this:

=item Usage

This genericStack should fit ok for small up to medium size stacks, not I<huge> stacks because of its internal usage of an array instead of a linked list. The later implementation is not that hard, but left as an exercise to the reader.

=over

=item GENERICSTACK_HAVE_LONG_LONG

If this #define is a true value, then C<long long> is supported.

=item GENERICSTACK_HAVE__BOOL

If this #define is a true value, then C<_Bool> is supported.

=item GENERICSTACK_HAVE__COMPLEX

If this #define is a true value, then C<float _Complex>, C<double _Complex> and C<long double _Complex> are supported.

=back

=back

=head1 EXAMPLE

  #include <stdio.h>
  #include <stdlib.h>
  #include "genericStack.h"
  
  void myFunction1(genericStack_t *myStackp);
  void myFunction2(genericStack_t *myStackp);
  void myFunction3(genericStack_t *myStackp);
  
  typedef struct myStruct1 {
    int i;
  } myStruct1_t;
  
  typedef struct myStruct2 {
    int i;
    char *s;
  } myStruct2_t;
  
  int main() {
    myStruct1_t     myStruct1 = { 50 };
    myStruct2_t     myStruct2 = { 60, "70" };
    genericStack_t *myStackp;
  
    GENERICSTACK_NEW(myStackp); if (GENERICSTACK_ERROR(myStackp)) { return 1; }
  
    printf("\NEW interface:\n");
    printf("--------------:\n\n");
    printf("Initial use/size: %d/%d\n", GENERICSTACK_USED(myStackp), GENERICSTACK_SIZE(myStackp));
  
    printf("\nPUSH interface:\n");
    printf("--------------:\n\n");
    
    printf("[ 0] int      : 10\n");                                    GENERICSTACK_PUSH_INT   (myStackp, 10);      if (GENERICSTACK_ERROR(myStackp)) { return 1; }
    printf("[ 1] double   : 20\n");                                    GENERICSTACK_PUSH_DOUBLE(myStackp, 20);      if (GENERICSTACK_ERROR(myStackp)) { return 1; }
    printf("[ 2] float    : 30\n");                                    GENERICSTACK_PUSH_FLOAT (myStackp, 30);      if (GENERICSTACK_ERROR(myStackp)) { return 1; }
    printf("[ 3] short    : 40\n");                                    GENERICSTACK_PUSH_SHORT (myStackp, 40);      if (GENERICSTACK_ERROR(myStackp)) { return 1; }
    printf("[ 4] myStruct1: {%d}\n", myStruct1.i);                     GENERICSTACK_PUSH_PTR(myStackp, &myStruct1); if (GENERICSTACK_ERROR(myStackp)) { return 1; }
    printf("[ 5] myStruct2: {%d,\"%s\"}\n", myStruct2.i, myStruct2.s); GENERICSTACK_PUSH_PTR(myStackp, &myStruct2); if (GENERICSTACK_ERROR(myStackp)) { return 1; }
  
    printf("Current use/size: %d/%d\n", GENERICSTACK_USED(myStackp), GENERICSTACK_SIZE(myStackp));
  
    myFunction1(myStackp);
  
    printf("\nSET interface:\n");
    printf("-------------:\n\n");
    
    printf("[10] float : 50\n"); GENERICSTACK_SET_FLOAT(myStackp, 50, 10); if (GENERICSTACK_ERROR(myStackp)) { return 1; }
  
    printf("Current use/size: %d/%d\n", GENERICSTACK_USED(myStackp), GENERICSTACK_SIZE(myStackp));
  
    myFunction2(myStackp);
    myFunction3(myStackp);
  
    return 0;
  }
  
  void myFunction1(genericStack_t *myStackp) {
    myStruct1_t *myStruct1p;
    myStruct2_t *myStruct2p;
    
    printf("\nGET interface:\n");
    printf("-------------:\n\n");
    printf("[ 1] double   : %f\n", (float) GENERICSTACK_GET_DOUBLE(myStackp, 1));
    printf("[ 0] int      : %d\n",         GENERICSTACK_GET_INT   (myStackp, 0));
    printf("[ 3] short    : %d\n",         GENERICSTACK_GET_SHORT (myStackp, 3));
    printf("[ 5] myStruct2: {%d, \"%s\"}\n", ((myStruct2_t *) GENERICSTACK_GET_PTR (myStackp, 5))->i, ((myStruct2_t *) GENERICSTACK_GET_PTR (myStackp, 5))->s);
    printf("[ 4] myStruct1: {%d}\n",         ((myStruct1_t *) GENERICSTACK_GET_PTR (myStackp, 4))->i);
    printf("[ 2] float    : %f\n",         GENERICSTACK_GET_FLOAT (myStackp, 2));
    
    printf("Current use/size: %d/%d\n", GENERICSTACK_USED(myStackp), GENERICSTACK_SIZE(myStackp));
  
    printf("\nPOP interface:\n");
    printf("-------------:\n\n");
    myStruct2p = (myStruct2_t *) GENERICSTACK_POP_PTR(myStackp);
    printf("[ 5] myStruct2: {%d, \"%s\"}\n", myStruct2p->i, myStruct2p->s);
    myStruct1p = (myStruct1_t *) GENERICSTACK_POP_PTR(myStackp);
    printf("[ 4] myStruct1: {%d}\n", myStruct1p->i);
    printf("[ 3] short : %d\n", (int)   GENERICSTACK_POP_SHORT(myStackp));
    printf("[ 2] float : %f\n",         GENERICSTACK_POP_FLOAT(myStackp));
    printf("[ 1] double: %f\n", (float) GENERICSTACK_POP_DOUBLE(myStackp));
    printf("[ 0] int   : %d\n",         GENERICSTACK_POP_INT(myStackp));
  
    printf("Current use/size: %d/%d\n", GENERICSTACK_USED(myStackp), GENERICSTACK_SIZE(myStackp));
  
  }
  
  void myFunction2(genericStack_t *myStackp) {
    
    printf("\nGET interface:\n");
    printf("-------------:\n\n");
    printf("[10] float : %f\n",         GENERICSTACK_GET_FLOAT (myStackp, 10));
  }
  
  void myFunction3(genericStack_t *myStackp) {
    
    printf("\nFREE interface:\n");
    printf("--------------:\n\n");
  
    GENERICSTACK_FREE(myStackp);
  }
  
